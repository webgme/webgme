/*globals define*/
/*jshint node:true, browser:true*/

/**
* Generated by PluginGenerator from webgme on Fri Apr 17 2015 11:49:47 GMT-0500 (Central Daylight Time).
*/
if (typeof define === 'undefined') {

} else {
    define([
        'plugin/PluginConfig',
        'plugin/PluginBase',
        'common/storage/constants'
    ], function (PluginConfig, PluginBase, STORAGE_CONSTANTS) {
        'use strict';

        /**
         * Initializes a new instance of PluginForked.
         * @class
         * @augments {PluginBase}
         * @classdesc This class represents the plugin PluginForked.
         * @constructor
         */
        var PluginForked = function () {
            // Call base class' constructor.
            PluginBase.call(this);
        };

        // Prototypal inheritance from PluginBase.
        PluginForked.prototype = Object.create(PluginBase.prototype);
        PluginForked.prototype.constructor = PluginForked;

        /**
         * Gets the name of the PluginForked.
         * @returns {string} The name of the plugin.
         * @public
         */
        PluginForked.prototype.getName = function () {
            return 'Plugin Forked';
        };

        /**
         * Gets the semantic version (semver.org) of the PluginForked.
         * @returns {string} The version of the plugin.
         * @public
         */
        PluginForked.prototype.getVersion = function () {
            return '0.1.0';
        };

        /**
         * Gets the description of the PluginForked.
         * @returns {string} The description of the plugin.
         * @public
         */
        PluginForked.prototype.getDescription = function () {
            return 'This plugin calls the main callback ';
        };

        PluginForked.prototype.getConfigStructure = function () {
            return [
                {
                    name: 'fork',
                    displayName: 'fork',
                    description: 'Inject a branchHashUpdate before save.',
                    value: false,
                    valueType: 'boolean',
                    readOnly: false
                },
                {
                    name: 'forkName',
                    displayName: 'forkName',
                    description: 'Name to save fork to.',
                    value: '',
                    valueType: 'string',
                    readOnly: false
                },
                {
                    name: 'timeout',
                    displayName: 'timeout',
                    description: 'Time before committing change',
                    value: 0,
                    valueType: 'number',
                    readOnly: false
                }
            ];
        };

        /**
         * Main function for the plugin to execute. This will perform the execution.
         * Notes:
         * - Always log with the provided logger.[error,warning,info,debug].
         * - Do NOT put any user interaction logic UI, etc. inside this method.
         * - callback always has to be called even if error happened.
         *
         * @param {function(string, plugin.PluginResult)} callback - the result callback
         */
        PluginForked.prototype.main = function (callback) {
            var self = this,
                persisted,
                config = self.getCurrentConfig();

            function makeAndSaveChanges() {
                self.core.setAttribute(self.activeNode, 'name', 'FCO_Own_Name');
                self.save('saving when config.forked = ' + config.fork.toString(), function (err, status) {
                    if (err) {
                        self.result.setSuccess(false);
                        callback(err, self.result);
                        return;
                    }
                    self.logger.debug('saved returned with status', status);
                    self.result.setSuccess(true);
                    callback(null, self.result);
                });
            }

            if (config.forkName) {
                self.forkName = config.forkName;
            }

            if (config.fork === true) {
                self.core.setAttribute(self.activeNode, 'name', 'FCO_Fork_Name');
                persisted = self.core.persist(self.rootNode);
                self.project.makeCommit(null,
                    [self.currentHash],
                    persisted.rootHash,
                    persisted.objects,
                    'Injected fork commit',
                    function (err, commitResult) {
                        if (err) {
                            self.logger.error('project.makeCommit failed.');
                            callback(err);
                            return;
                        }
                        self.project.setBranchHash(self.branchName, commitResult.hash, self.currentHash,
                            function (err, commitResult) {
                                if (commitResult.status === STORAGE_CONSTANTS.SYNCED) {
                                    makeAndSaveChanges();
                                } else {
                                    callback('Injected commit was not in sync, ' + commitResult.status);
                                }
                            }
                        );
                    }
                );
            } else {
                setTimeout(makeAndSaveChanges, config.timeout);
            }
        };

        return PluginForked;
    });
}