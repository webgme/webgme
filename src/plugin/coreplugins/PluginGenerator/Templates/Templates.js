//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "combine_templates.js.ejs": "/*jshint node:true*/\n/**\n * Generated by PluginGenerator <%= version %> from webgme on <%= date %>.\n *\n * This script will combine all ejs files in the current directory (recursively)\n * into one Templates.js file. By requiring this file as TEMPLATE you can retrieve the\n * content of each original ejs file through TEMPLATES['plugin.js.ejs'].\n *\n * Usage: Run this script in the directory with the ejs-templates, e.g. '%YourPlugin%/Templates'.\n *\n * @author lattmann / https://github.com/lattmann\n * @author pmeijer / https://github.com/pmeijer\n * @ignore\n */\n\nvar main = function () {\n    'use strict';\n    var fs = require('fs'),\n        isEjsFile = function (str) {\n            var ending = '.ejs',\n            lastIndex = str.lastIndexOf(ending);\n            return (lastIndex !== -1) && (lastIndex + ending.length === str.length);\n        },\n        walk = function (dir, done) {\n            var results = [];\n            fs.readdir(dir, function (err, list) {\n                if (err) {\n                    return done(err);\n                }\n                var i = 0;\n                (function next() {\n                    var file = list[i];\n                    if (!file) {\n                        return done(null, results);\n                    }\n                    i += 1;\n                    file = dir + '/' + file;\n                    fs.stat(file, function (err, stat) {\n                        if (stat && stat.isDirectory()) {\n                            walk(file, function (err, res) {\n                                results = results.concat(res);\n                                next();\n                            });\n                        } else {\n                            results.push(file);\n                            next();\n                        }\n                    });\n                })();\n            });\n        },\n        content = {},\n        fileName,\n        i,\n        templateContent;\n\n    walk('.', function (err, results) {\n        if (err) {\n            throw err;\n        }\n\n        for (i = 0; i < results.length; i += 1) {\n            fileName = results[i];\n            console.info(fileName);\n            if (isEjsFile(fileName)) {\n                console.info('Was ejs -> added!');\n                content[fileName.substring(2)] = fs.readFileSync(fileName, {'encoding': 'utf-8'});\n            }\n        }\n\n        console.info(content);\n        templateContent = '';\n        templateContent += '/* Generated file based on ejs templates */\\r\\n';\n        templateContent += 'define([], function() {\\r\\n';\n        templateContent += '    return ' + JSON.stringify(content, null, 4);\n        templateContent += '});';\n\n        fs.writeFileSync('Templates.js', templateContent);\n        console.info('Created Templates.js');\n    });\n};\n\nif (require.main === module) {\n    main();\n}",
    "meta.js.ejs": "/**\n * Generated by PluginGenerator <%= version %> from webgme on <%= date %>.\n */\n\ndefine([], function () {\n    'use strict';\n    return {\n<%\nvar nodeData, i;\nfor (i = 0; i < metaNodes.length; i += 1) {\n    nodeData = metaNodes[i];%>        '<%= nodeData.name %>': '<%= nodeData.path %>',\n<%}%>    };\n});",
    "metadata.json.ejs": "{\n  \"id\": \"<%= pluginID %>\",\n  \"name\": \"<%= pluginName %>\",\n  \"version\": \"0.1.0\",\n  \"description\": \"<%= description %>\",\n  \"icon\": {\n    \"class\": \"glyphicon glyphicon-cog\",\n    \"src\": \"\",\n  },\n  \"disableServerSideExecution\": false,\n  \"disableBrowserSideExecution\": false,<%if (configStructure) {%>\n  \"configStructure\": [\n    {\n      \"name\": \"species\",\n      \"displayName\": \"Animal Species\",\n      \"regex\": \"^[a-zA-Z]+$\",\n      \"regexMessage\": \"Name can only contain English characters!\",\n      \"description\": \"Which species does the animal belong to.\",\n      \"value\": \"Horse\",\n      \"valueType\": \"string\",\n      \"readOnly\": false\n    },\n    {\n      \"name\": \"age\",\n      \"displayName\": \"Age\",\n      \"description\": \"How old is the animal.\",\n      \"value\": 3,\n      \"valueType\": \"number\",\n      \"minValue\": 0,\n      \"maxValue\": 10000,\n      \"readOnly\": false\n    },\n    {\n      \"name\": \"carnivore\",\n      \"displayName\": \"Carnivore\",\n      \"description\": \"Does the animal eat other animals?\",\n      \"value\": false,\n      \"valueType\": \"boolean\",\n      \"readOnly\": false\n    },\n    {\n      \"name\": \"classification\",\n      \"displayName\": \"Classification\",\n      \"description\": \"\",\n      \"value\": \"Vertebrates\",\n      \"valueType\": \"string\",\n      \"valueItems\": [\n        \"Vertebrates\",\n        \"Invertebrates\",\n        \"Unknown\"\n      ]\n    },\n    {\n      \"name\": \"color\",\n      \"displayName\": \"Color\",\n      \"description\": \"The hex color code for the animal.\",\n      \"readOnly\": false,\n      \"value\": \"#FF0000\",\n      \"regex\": \"^#([A-Fa-f0-9]{6})$\",\n      \"valueType\": \"string\"\n    },\n    {\n      \"name\": \"anAsset\",\n      \"displayName\": \"Document\",\n      \"description\": \"\",\n      \"value\": \"\",\n      \"valueType\": \"asset\",\n      \"readOnly\": false\n    }\n  ]<%} else {%>\n  \"configStructure\": []\n<%}%>\n}",
    "plugin.js.ejs": "/*globals define*/\n/*jshint node:true, browser:true*/\n\n/**\n * Generated by PluginGenerator <%= version %> from webgme on <%= date %>.\n */\n\ndefine([\n    'plugin/PluginConfig',\n    'text!./metadata.json',\n    'plugin/PluginBase'<%if (meta) {%>,\n    'plugin/<%= pluginID %>/<%= pluginID %>/meta'<%}%><%if (templateType) {%>,\n    'common/util/ejs',\n    'plugin/<%=pluginID%>/<%=pluginID%>/Templates/Templates'<%}%>\n], function (\n    PluginConfig,\n    pluginMetadata,\n    PluginBase<%if (meta) {%>,\n    MetaTypes<%}%><%if (templateType) {%>,\n    ejs,\n    TEMPLATES<%}%>) {\n    'use strict';\n\n    pluginMetadata = JSON.parse(pluginMetadata);\n\n    /**\n     * Initializes a new instance of <%= pluginID %>.\n     * @class\n     * @augments {PluginBase}\n     * @classdesc This class represents the plugin <%= pluginID %>.\n     * @constructor\n     */\n    var <%= pluginID %> = function () {\n        // Call base class' constructor.\n        PluginBase.call(this);<%if (meta) {%>\n        this.metaTypes = MetaTypes;<%}%>\n        this.pluginMetadata = pluginMetadata;\n    };\n\n    /**\n     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.\n     * This is also available at the instance at this.pluginMetadata.\n     * @type {object}\n     */\n    <%= pluginID %>.metadata = pluginMetadata;\n\n    // Prototypical inheritance from PluginBase.\n    <%= pluginID %>.prototype = Object.create(PluginBase.prototype);\n    <%= pluginID %>.prototype.constructor = <%= pluginID %>;\n\n    /**\n     * Main function for the plugin to execute. This will perform the execution.\n     * Notes:\n     * - Always log with the provided logger.[error,warning,info,debug].\n     * - Do NOT put any user interaction logic UI, etc. inside this method.\n     * - callback always has to be called even if error happened.\n     *\n     * @param {function(string, plugin.PluginResult)} callback - the result callback\n     */\n    <%= pluginID %>.prototype.main = function (callback) {\n        // Use self to access core, project, result, logger etc from PluginBase.\n        // These are all instantiated at this point.\n        var self = this,\n            nodeObject;\n<%if (meta) {%>\n        self.updateMETA(self.metaTypes);<%}%>\n\n        // Using the logger.\n        self.logger.debug('This is a debug message.');\n        self.logger.info('This is an info message.');\n        self.logger.warn('This is a warning message.');\n        self.logger.error('This is an error message.');\n\n        // Using the coreAPI to make changes.\n<%if (meta) {%>\n        nodeObject = self.core.createNode({parent: self.rootNode, base: self.META.FCO});<%} else {%>\n        nodeObject = self.activeNode;\n<%}%>\n        self.core.setAttribute(nodeObject, 'name', 'My new obj');\n        self.core.setRegistry(nodeObject, 'position', {x: 70, y: 70});\n\n<%if (configStructure) {%>\n        // Obtain the current user configuration.\n        var currentConfig = self.getCurrentConfig();\n        self.logger.info('Current configuration ' + JSON.stringify(currentConfig, null, 4));\n<%}\nif (templateType) {%>\n        // First transform ejs-files into js files (needed for client-side runs) -> run Templates/combine_templates.js.\n        // See instructions in file. You must run this after any modifications to the ejs template.\n        var template<%=templateExt.toUpperCase()%> = ejs.render(TEMPLATES['<%=templateType%>.<%=templateExt%>.ejs'], {a: 'a', b: 'b'});\n        var templateFileName = 'generatedFiles/subDir/<%=templateType%>.<%=templateExt%>';\n        var artifact = self.blobClient.createArtifact('templateFiles');\n        artifact.addFile(templateFileName, template<%=templateExt.toUpperCase()%>, function (err) {\n            if (err) {\n                callback(err, self.result);\n                return;\n            }\n            self.blobClient.saveAllArtifacts(function (err, hashes) {\n                if (err) {\n                    callback(err, self.result);\n                    return;\n                }\n                // This will add a download hyperlink in the result-dialog.\n                self.result.addArtifact(hashes[0]);\n                // This will save the changes. If you don't want to save;\n                // exclude self.save and call callback directly from this scope.\n                self.save('<%= pluginName %> updated model.', function (err) {\n                    if (err) {\n                        callback(err, self.result);\n                        return;\n                    }\n                    self.result.setSuccess(true);\n                    callback(null, self.result);\n                });\n            });\n        });\n<%} else {%>\n        // This will save the changes. If you don't want to save;\n        // exclude self.save and call callback directly from this scope.\n        self.save('<%= pluginName %> updated model.', function (err) {\n            if (err) {\n                callback(err, self.result);\n                return;\n            }\n            self.result.setSuccess(true);\n            callback(null, self.result);\n        });\n<%}%>\n    };\n\n    return <%= pluginID %>;\n});",
    "unit_test.js.ejs": "/*jshint node:true, mocha:true*/\n/**\n * Generated by PluginGenerator <%= version %> from webgme on <%= date %>.\n */\n\n'use strict';\nvar testFixture = require('../../../_globals');\n\ndescribe('<%= pluginID %>', function () {\n    var gmeConfig = testFixture.getGmeConfig(),\n        expect = testFixture.expect,\n        logger = testFixture.logger.fork('<%= pluginID %>'),\n        PluginCliManager = testFixture.WebGME.PluginCliManager,\n        projectName = 'testProject',\n        pluginName = '<%= pluginID %>',\n        project,\n        gmeAuth,\n        storage,\n        commitHash;\n\n    before(function (done) {\n        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)\n            .then(function (gmeAuth_) {\n                gmeAuth = gmeAuth_;\n                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.\n                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);\n                return storage.openDatabase();\n            })\n            .then(function () {\n                var importParam = {\n                    projectSeed: testFixture.path.join(testFixture.SEED_DIR, 'EmptyProject.json'),\n                    projectName: projectName,\n                    branchName: 'master',\n                    logger: logger,\n                    gmeConfig: gmeConfig\n                };\n\n                return testFixture.importProject(storage, importParam);\n            })\n            .then(function (importResult) {\n                project = importResult.project;\n                commitHash = importResult.commitHash;\n                return project.createBranch('test', commitHash);\n            })\n            .nodeify(done);\n    });\n\n    after(function (done) {\n        storage.closeDatabase()\n            .then(function () {\n                return gmeAuth.unload();\n            })\n            .nodeify(done);\n    });\n\n    it('should run plugin and update the branch', function (done) {\n        var manager = new PluginCliManager(null, logger, gmeConfig),\n            pluginConfig = {\n            },\n            context = {\n                project: project,\n                commitHash: commitHash,\n                branchName: 'test',\n                activeNode: '/960660211',\n            };\n\n        manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {\n            expect(err).to.equal(null);\n            expect(typeof pluginResult).to.equal('object');\n            expect(pluginResult.success).to.equal(true);\n\n            project.getBranchHash('test')\n                .then(function (branchHash) {\n                    expect(branchHash).to.not.equal(commitHash);\n                })\n                .nodeify(done);\n        });\n    });\n});\n"
}});