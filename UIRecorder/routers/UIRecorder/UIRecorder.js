/*globals define*/
/*jshint node:true*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Thu Dec 15 2016 14:21:04 GMT-0600 (Central Standard Time).
 * To use in webgme add to gmeConfig.rest.components[<routePath>] = filePath.
 *
 * If you put this file in the root of your directory the following config,
 * gmeConfig.rest.component['path/subPath'] = path.join(process.cwd(), './UIRecorder')
 * will expose, e.g. GET <host>/path/subPath/getExample, when running the server.
 */

'use strict';

// http://expressjs.com/en/guide/routing.html
var express = require('express'),
    router = express.Router(),
    Q = require('q'),
    fs = require('fs'),
    path = require('path'),
    mongodb = require('mongodb'),
    ROUTER_CONFIG_FILE_PATH = path.join(process.cwd(), 'UIRecorderRouterConfig.json'),
    defaultConfig = {
        mongo: {
            uri: 'mongodb://127.0.0.1:27017/UIRecordingData',
            options: {}
        }
    },
    config,
    dbConn;

function getConfig() {
    var deferred = Q.defer();
    fs.readFile(ROUTER_CONFIG_FILE_PATH, 'utf8', function (err, content) {
        if (err) {
            if (err.code === 'ENOENT') {
                console.warn('Did not find', ROUTER_CONFIG_FILE_PATH, 'using default config',
                    JSON.stringify(defaultConfig));

                deferred.resolve(defaultConfig);
            } else {
                deferred.reject(err);
            }
        } else {
            deferred.resolve(JSON.parse(content));
        }
    });

    return deferred.promise;
}

/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
    var logger = middlewareOpts.logger.fork('UIRecorder'),
        ensureAuthenticated = middlewareOpts.ensureAuthenticated,
        getUserId = middlewareOpts.getUserId;

    logger.debug('initializing ...');

    // Ensure authenticated can be used only after this rule.
    router.use('*', function (req, res, next) {
        // This header ensures that any failures with authentication won't redirect.
        res.setHeader('X-WebGME-Media-Type', 'webgme.v1');
        next();
    });

    // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
    router.use('*', ensureAuthenticated);

    router.get('/:ownerId/:projectName/status/:commitHash', function (req, res, next) {
        var userId = getUserId(req);

        Q.ninvoke(dbConn, 'collection', req.params.ownerId + '+' + req.params.projectName)
            .then(function (collection) {
                return Q.ninvoke(collection, 'findOne', {_id: '#' + req.params.commitHash});
            })
            .then(function (result) {
                var status = {
                    exists: !!result
                };

                res.json(status);
            })
            .catch(function (err) {
                logger.error(err);
                next(err);
            });
    });

    router.get('/recordings', function (req, res, next) {
        var userId = getUserId(req),
            collection;

        Q.ninvoke(dbConn, 'collection', req.body.projectId)
            .then(function (result) {
                collection = result;
                return Q.all(req.body.commitHashes.map(function (commitHash) {
                    Q.ninvoke(collection, 'findOne', {_id: commitHash});
                }));
            })
            .then(function (result) {
                var records = [];

                result.forEach(function (record) {
                    if (record) {
                        records.push(record);
                    } else {
                        logger.error('missing record');
                    }
                });

                res.json(records);
            })
            .catch(function (err) {
                next(err);
            });
    });

    router.put('/recording', function (req, res, next) {
        var collection;

        //TODO: Check write access

        Q.ninvoke(dbConn, 'collection', req.body.projectId)
            .then(function (result) {
                collection = result;
                return Q.ninvoke(collection, 'insert', req.body);
            })
            .then(function () {
                res.sendStatus(201);
            })
            .catch(function (err) {
                logger.error(err);
                next(err);
            });
    });
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
    getConfig()
        .then(function(config_) {
            var dbDeferred = Q.defer();
            config = config_;
            mongodb.MongoClient.connect(config.mongo.uri, config.mongo.options, function (err, db) {
                if (err) {
                    dbDeferred.reject(err);
                } else {
                    dbConn = db;
                    dbDeferred.resolve();
                }
            });

            return dbDeferred.promise;
        })
        .nodeify(callback);
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
    callback();
}


module.exports = {
    initialize: initialize,
    router: router,
    start: start,
    stop: stop
};
